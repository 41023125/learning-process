var tipuesearch = {"pages": [{'title': 'About', 'text': '這裡將放置學習python的所有過程 \n 以便將來回憶與查詢 \n 網站網址: https://41023125.github.io/learning-process/ \n \n', 'tags': '', 'url': 'About.html'}, {'title': 'web page', 'text': '這裡放置 所學編寫網頁之知識 \n \n', 'tags': '', 'url': 'web page.html'}, {'title': '模板', 'text': '所使用模板 \n cmsimde.zip \n', 'tags': '', 'url': '模板.html'}, {'title': 'OpenCV', 'text': '使用python進行圖片處理 \n', 'tags': '', 'url': 'OpenCV.html'}, {'title': '處理與比較', 'text': '\n \n import cv2\nimport numpy as np\n\njpg1 = r"C:\\initpython\\ph\\Screenshot_20230406-192510.jpg"\nimage = cv2.imread(jpg1)\n\n\n# 裁剪\ndef pag(image, start_x, start_y):\n    end_x = 95\n    end_y = 95\n    return image[start_y:start_y+end_y, start_x:start_x+end_x]\n\n\n# 比較\ndef mse(image1, image2):\n    err = np.sum((image1.astype("float") - image2.astype("float")) ** 2)\n    err /= float(image1.shape[0] * image1.shape[1])\n    if err == 0:\n        return 100.0\n    else:\n        psnr = 10 * np.log10(255**2 / err)\n        similarity = (psnr / 50) * 100\n        return similarity\n\n\nimage1 = pag(image, 195, 1090)\nimage2 = cv2.imread(r"C:\\initpython\\ph\\jpg\\phcropped_image.png")\n\n\n# 顯示圖片\n\'\'\'\ncv2.imshow("Cropped Image", image2)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n\'\'\'\n\n# 儲存\n# cv2.imwrite("phcropped_image.png", image1)\nprint("相似度: ", mse(image1, image2))\n \n \n \n', 'tags': '', 'url': '處理與比較.html'}, {'title': '辨識初步程式架構', 'text': 'import os\nimport cv2\nimport numpy as np\n\njpg1 = r"C:\\Users\\alin\\Nox_share\\ImageShare\\Screenshots\\Screenshot_20230406-230719.png"\nimage = cv2.imread(jpg1)\n\n\n# 裁剪\ndef pag(image, start_x, start_y):\n    end_x = 95\n    end_y = 95\n    return image[start_y:start_y+end_y, start_x:start_x+end_x]\n\n\n# 比較\ndef mse(image1, image2):\n    err = np.sum((image1.astype("float") - image2.astype("float")) ** 2)\n    err /= float(image1.shape[0] * image1.shape[1])\n    if err == 0:\n        return 100.0\n    else:\n        psnr = 10 * np.log10(255**2 / err)\n        similarity = (psnr / 50) * 100\n        return similarity\n\n\n# 查詢類別\ndef read_file(num):\n    mapping = {}\n    with open("ph\\\\dictionary.txt", \'r\', encoding=\'utf-8\') as f:\n        # 读取文件内容\n        lines = f.readlines()\n        for line in lines:\n            parts = line.split()\n            if len(parts) == 2:\n                key = int(parts[0])\n                value = parts[1]\n                mapping[key] = value\n    if num in mapping:\n        print(mapping[num])\n    else:\n        print(\'設置出現錯誤\')\n\n\n# 檢查圖庫數量\ndef count_files():\n    folder_path = "ph\\\\jpg"\n    files = os.listdir(folder_path)\n    return len(files)\n\n\nimage1 = pag(image, 195, 1090)\n# image2 = cv2.imread(r"C:\\initpython\\ph\\jpg\\5.png")\n\n\n# 顯示圖片\n\'\'\'\ncv2.imshow("Cropped Image", image1)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n\'\'\'\n\n# 儲存\n# cv2.imwrite("phcropped_image.png", image1)\n\nmes = 0\nass = 0\nfor i in range(1, count_files()+1):\n    image2 = cv2.imread("ph\\\\jpg\\\\" + str(i) + ".png")\n    print("相似度: ", mse(image1, image2), "%")\n    if mes < mse(image1, image2):\n        mes = mse(image1, image2)\n        ass = i\n    if mes < 10:\n        ass = 999\nread_file(ass)\ncv2.imshow("Cropped Image", image1)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n \n \n', 'tags': '', 'url': '辨識初步程式架構.html'}, {'title': 'adb', 'text': '\n 學習利用python控制手機與模擬器 \n 如何在 WIN10 安裝 Android ADB工具 \n 如何讓 NOX 夜神模擬器支援 ADB \n Android adb 基本用法教學 \n 【新手指导】夜神安卓模拟器adb命令详解_夜神安卓模拟器新手帮助页 (yeshen.com) \n 可以使用 \n adb shell pm list packages | findstr dice\n \n 指令來查看當前顯示的應用程式的相關資訊，其中 mCurrentFocus 顯示目前的視窗和活動的應用程式包名和類名，mFocusedApp 顯示當前焦點的應用程式包名和進程 ID。可以在模擬器或設備上執行此指令，以獲得目標應用程式的包名和主活動。 \n 假設輸出了package:com.percent.royaldice \n 可以使用 \n adb shell monkey -p com.percent.royaldice -c android.intent.category.LAUNCHER 1 \n \n 打開程式 \n 使用 \n adb shell am force-stop com.percent.royaldice \n \n 關閉程式 \n \n', 'tags': '', 'url': 'adb.html'}, {'title': '列出設備上的應用程式', 'text': "from ppadb.client import Client\n \n# 建立 ADB 連線\nadb = Client(host='127.0.0.1', port=5037)\ndevice = adb.device('127.0.0.1:62001')\n \n# 取得所有已安裝應用程式列表\nresult = device.shell('pm list packages')\npackages = [line.strip()[8:] for line in result.split('\\n') if line.strip()]\n \n# 列出所有應用程式名稱\nfor package in packages:\n    print(package) \n", 'tags': '', 'url': '列出設備上的應用程式.html'}, {'title': '測試端口是否正常連接', 'text': 'import socket\n\n# 設置主機地址和端口號\nhost = \'127.0.0.1\'\nport = 62001\n\n# 創建套接字對象\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# 嘗試連接主機和端口號\nresult = sock.connect_ex((host, port))\n\n# 檢查連接結果\nif result == 0:\nprint("端口連接成功！")\nelse:\nprint("端口連接失敗。")\n\n# 關閉套接字對象\nsock.close() \n \n', 'tags': '', 'url': '測試端口是否正常連接.html'}, {'title': '取得目前應用程式的包名稱和主活動', 'text': 'from ppadb.client import Client\n\n# 建立 ADB 連線\nadb = Client(host=\'127.0.0.1\', port=5037)\ndevice = adb.device(\'127.0.0.1:62001\')\n\n# 查詢目前應用程式的包名稱和主活動\noutput = device.shell(\'dumpsys window windows | grep -E "mCurrentFocus"\')\npackage_activity = output.split(\' \')[-1].split(\'/\')\npackage_name = package_activity[0]\nactivity_name = package_activity[1].strip()\n\n# 開啟應用程式\n#device.shell(f"am start -n {package_name}/{activity_name}") \n 輸出結果範例: \n com.percent.royaldice com.google.firebase.MessagingUnityPlayerActivity} \n 分別帶入後變成 \n \n package_name  =  \'com.percent.royaldice\' \n activity_name  =  \'com.google.firebase.MessagingUnityPlayerActivity\' \n 便能利用\n \n device .shell( f "am start -n  { package_name } / { activity_name } " ) \n 開啟想要開啟的程式 \n \n \n \n \n', 'tags': '', 'url': '取得目前應用程式的包名稱和主活動.html'}, {'title': '截圖', 'text': 'import subprocess\n\nsubprocess.run("adb shell screencap -p /sdcard/screenshot.png")\nsubprocess.run("adb pull /sdcard/screenshot.png .")\nsubprocess.run("adb shell rm /sdcard/screenshot.png") \n \n', 'tags': '', 'url': '截圖.html'}, {'title': '點擊', 'text': "\n \n import subprocess\n\n\ndef click(x, y):\n\xa0 \xa0 subprocess.run(['adb', 'shell', f'input tap {x} {y}'])\n\n\nclick(500, 500) \xa0# 點擊座標 (500, 500)\n \n \n \n", 'tags': '', 'url': '點擊.html'}, {'title': 'tel2023', 'text': 'labview程式: \n https://drive.google.com/file/d/1jeEyfaqDKvxz0uE1AdAojRzPLV_Hj38D/view?usp=share_link/ \n', 'tags': '', 'url': 'tel2023.html'}, {'title': '直線校正', 'text': '直線校正.zip \n \n 使用python編寫 \n 下方為程式碼 \n import tkinter as tk\n\n\nclass Application(tk.Frame):\n    def __init__(self, master=None):\n        super().__init__(master)\n        self.master = master\n        self.pack()\n        self.create_widgets()\n\n    def create_widgets(self):\n        self.input2_label = tk.Label(self, text="實際距離:")\n        self.input2_label.pack()\n        self.input2 = tk.Entry(self)\n        self.input2.pack()\n\n        self.input3_label = tk.Label(self, text="當前輪徑:")\n        self.input3_label.pack()\n        self.input3 = tk.Entry(self)\n        self.input3.pack()\n\n        self.submit_button = tk.Button(\n            self, text="計算", command=self.show_output)\n        self.submit_button.pack()\n\n        self.output_label = tk.Label(self, text="輪徑:")\n        self.output_label.pack()\n        self.output = tk.Label(self, text="")\n        self.output.pack()\n\n        self.quit_button = tk.Button(\n            self, text="Quit", command=self.master.quit)\n        self.quit_button.pack()\n\n    def show_output(self):\n        input2_value = self.input2.get()\n        input3_value = self.input3.get()\n\n        # 在這裡加上你的處理邏輯，將結果顯示在output的Label中\n        input2_value = float(self.input2.get())\n        input3_value = float(self.input3.get())\n        output_value = (input3_value * input2_value) / 1000\n        self.output.config(text=output_value)\n\n\nroot = tk.Tk()\napp = Application(master=root)\napp.mainloop()\n \n \n', 'tags': '', 'url': '直線校正.html'}, {'title': '連接python', 'text': '\n', 'tags': '', 'url': '連接python.html'}, {'title': 'Unity', 'text': '\n \n \n \n void   Start (){}//開始時只執行一次 \n \n \n void   Update () {}//重複執行 \n \n \n \n \n Debug.Log(123); //將括號內容顯示在consoleg上面 \n public //公用 \n \n [ SerializeField ] \n rigidbody 剛體 \n collider 碰撞 \n \n \n \n private   void   OnCollisionEnter2D ( Collision2D   other )  \n \xa0 \xa0 { \n \xa0 \xa0 \xa0 \xa0 \n \n \xa0 \xa0 \xa0 \xa0 if ( other . gameObject . tag   ==   "food" ) \n \xa0 \xa0 \xa0 \xa0 { \n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  Debug . Log ( "撞到了" ); \n \xa0 \xa0 \xa0 \xa0 } \n \n \n \xa0 \xa0 }//碰撞檢測 \n \n \n \n gameObject 遊戲對象 \n \n \n \n \n \n \n', 'tags': '', 'url': 'Unity.html'}, {'title': '專案', 'text': '', 'tags': '', 'url': '專案.html'}, {'title': 'RD', 'text': 'RD \n 4/6開始執行方案 \n 目標做成自動排版RD版面的python程式 \n 預計使用夜神模擬器在電腦執行\xa0 \n 自動判斷並移動 \n 使用 abd 進行操控並獲取畫面 \n 使用 OpenCV 辨識處理 \n', 'tags': '', 'url': 'RD.html'}, {'title': '檢查版面上的骰子', 'text': '預設值 \n addx 195 \n addy 1010 #訓練場1090 \n end_x 95 \n end_y 95 \n \n addx +( 9 + 95 )* x \n \n \n addy -( 5 + 95 )*y \n \n *將運算更改成多線程 \n \n \n \n \n \n # pylint: disable=no-member\n"""\n此注釋用來禁用警告\n"""\n# 計算全部種類只用一次\nimport os\nimport numpy as np\nimport cv2\nimport time\nfrom concurrent import futures\n# 查看圖片\ndef timer(func):\n    def wrapper(*args, **kwargs):\n        start_time = time.time()\n        result = func(*args, **kwargs)\n        end_time = time.time()\n        print("程式運行時間：{:.2f}秒".format(end_time - start_time))\n        return result\n    return wrapper\n\ndef look(aimage):\n    """\n    用來查看圖片\n    :aimage: 選擇顯示的圖片\n\n    """\n    cv2.imshow("Cropped Image", aimage)\n    cv2.waitKey(0)\n    cv2.destroyAllWindows()\n\n\ndef pag(aimage, start_x, start_y):\n    """\n    用來裁剪圖片成指定大小\n    :aimage: 選擇的圖片\n    :start_x:起始X座標\n    :start_y:起始y座標\n    """\n    end_x = 95\n    end_y = 95\n    return aimage[start_y:start_y+end_y, start_x:start_x+end_x]\n\n\ndef mse(image1, image2):\n    """\n    比較兩張圖片相似度\n    返回百分比\n    """\n    err = np.sum((image1.astype("float") - image2.astype("float")) ** 2)\n    err /= float(image1.shape[0] * image1.shape[1])\n    if err == 0:\n        return 100.0\n    else:\n        psnr = 10 * np.log10(255**2 / err)\n        similarity = (psnr / 50) * 100\n        return similarity\n\n\ndef read_file(num):\n    """\n    返回數字在文本對應的內容\n    """\n    mapping = {}\n    with open("dictionary.txt", \'r\', encoding=\'utf-8\') as f:\n        # 读取文件内容\n        lines = f.readlines()\n        for line in lines:\n            parts = line.split()\n            if len(parts) == 2:\n                key = int(parts[0])\n                value = parts[1]\n                mapping[key] = value\n    if num in mapping:\n        return mapping[num]\n    else:\n        print(\'未在dictionary.txt增新\'+str(num)+"對應名稱")\n        return\n\n\ndef count_files():\n    """\n    返回圖庫的檔案數量\n    """\n    folder_path = "jpg"\n    files = os.listdir(folder_path)\n    return len(files)\n\n\ndef check(image1):\n    """\n    比較圖庫所有內容並返回最相近的名稱\n    if mes < 30:\n            # 儲存圖片\n            cv2.imwrite(\'jpg/\'+str((count_files()))+".png", image1)\n            with open("ph\\\\dictionary.txt", \'a\', encoding=\'utf-8\') as f:\n                count = int(count_files()) - 1\n                f.write(str(count) + \'    \'+read_file(ass)+\'\\n\')\n            # print(count)\n        # 顯示圖片\n        look(image1)\n    """\n    mes = aass = 0\n    for i in range(0, count_files()):\n        image2 = cv2.imread("jpg\\\\" + str(i) + ".png")\n        # print("相似度: ", mse(image1, image2), "%")\n        if mse(image1, image2) >50:\n            mes = mse(image1, image2)\n            aass = i\n            break\n        if mes < mse(image1, image2):\n            mes = mse(image1, image2)\n            aass = i\n    # print(aass)\n    aass = read_file(aass)\n    # print(mes)\n    return aass\n\n\n# 將陣列展示\ndef output(my_array):\n    """\n    將陣列合成字串並返回用於展示\n    """\n    aoutput = \'\'\n    for _, row in enumerate(my_array):\n        for _, value in enumerate(row):\n            aoutput += str(value) + \' \'\n        aoutput += \'\\n\'\n    return aoutput\n\n# 檢查全部\n\n_=\'\'\'單線程棄用\n@timer\ndef check_all(aimage):\n    """\n    檢查全部的圖片並返回成陣列\n    單片檢查\n    image1 = pag(image, addx+(9+95)*0, addy-(5+95)*2)\n    look(image1)\n    """\n    addx = 195\n    addy = 1090\n    # x 9 # y 5 # addx = 195 # addy = 1010\n    # 创建一个3x5的空二维數组\n    my_array = [[0 for j in range(5)] for i in range(3)]\n    for xx in range(5):\n        for yy in range(3):\n            image1 = pag(aimage, addx+(9+95)*xx, addy-(5+95)*yy)\n            my_array[yy][xx] = check(image1)\n    my_array = my_array[::-1]\n    outpu = output(my_array)\n    print(outpu)\n    return my_array\n\'\'\'\n@timer\ndef check_all(aimage):\n    """\n    檢查全部的圖片並返回成陣列\n    單片檢查\n    image1 = pag(image, addx+(9+95)*0, addy-(5+95)*2)\n    look(image1)\n    """\n    addx = 195\n    addy = 1090\n    # x 9 # y 5 # addx = 195 # addy = 1010\n    # 创建一个3x5的空二维數组\n    my_array = [[0 for j in range(5)] for i in range(3)]\n    futures_list = []\n    with futures.ThreadPoolExecutor() as executor:\n        for xx in range(5):\n            for yy in range(3):\n                image1 = pag(aimage, addx+(9+95)*xx, addy-(5+95)*yy)\n                future = executor.submit(check, image1)\n                futures_list.append((future, xx, yy))\n        for f, xx, yy in sorted(futures_list, key=lambda x: (x[1], x[2])):\n            my_array[yy][xx] = f.result()\n    my_array = my_array[::-1]\n    outpu = output(my_array)\n    print(outpu)\n    return my_array\n\n\n# 測試\n\'\'\'\nJPG1 = "screenshot2.png"\nimage = cv2.imread(JPG1)\nass = check_all(image)\n#print(ass)\n\'\'\' \n \n \n', 'tags': '', 'url': '檢查版面上的骰子.html'}, {'title': '檢查造骰按鈕狀態', 'text': '預設值 \n addx 195 \n addy 1010 \n end_x 95 \n end_y\xa020 \n \n \n # pylint: disable=no-member\n"""\n此注釋用來禁用警告\n"""\n# 檢查造骰按鈕狀態\nimport numpy as np\nimport cv2\n\n\ndef pushbutton(aimage):\n    """\n    檢查按鈕狀態\n    """\n    addx = 195\n    addy = 1090\n    aimage1 = pag(aimage, addx+(9+95)*2, addy-(5+95)*-2)\n    aimage1 = check(aimage1)\n    return aimage1\n\n\ndef pag(aimage, start_x, start_y):\n    """\n    裁剪圖片\n    """\n    end_x = 95\n    end_y = 20\n    return aimage[start_y:start_y+end_y, start_x:start_x+end_x]\n\n\ndef mse(image1, image2):\n    """\n    比對兩張圖片相似度\n    """\n    err = np.sum((image1.astype("float") - image2.astype("float")) ** 2)\n    err /= float(image1.shape[0] * image1.shape[1])\n    if err == 0:\n        return 100.0\n    else:\n        psnr = 10 * np.log10(255**2 / err)\n        similarity = (psnr / 50) * 100\n        return similarity\n\n\ndef check(image1):\n    """\n    返回對應狀態\n    """\n    mes = ass = 0\n    for i in range(1, 4):\n        if i == 1:\n            x = "open"\n        elif i == 2:\n            x = "closure"\n        else:\n            x = "error"\n        image2 = cv2.imread("ph\\\\summon\\\\" + x + ".png")\n        # print("相似度: ", mse(image1, image2), "%")\n        if mes < mse(image1, image2):\n            mes = mse(image1, image2)\n            ass = x\n    _ = \'\'\'\n    #檢查圖片\n    from database import look\n    look(image1)\'\'\'\n\n    return (ass)\n\n\n# 測試\nJPG1 = "ph//screenshot1.png"\nimage = cv2.imread(JPG1)\nprint(pushbutton(image))\n \n \n', 'tags': '', 'url': '檢查造骰按鈕狀態.html'}, {'title': '測試框選範圍', 'text': '\n \n # pylint: disable=no-member\n"""\n此注釋用來禁用警告\n"""\n# 測試圖片\nimport cv2\nfrom database import look\n\n\ndef pag(aimage):\n\xa0 \xa0 """"\n\xa0 \xa0 裁剪圖片\n\xa0 \xa0 """\n\xa0 \xa0 addx = 195\n\xa0 \xa0 addy = 1090\n\xa0 \xa0 start_x = addx+(9+95)*0\n\xa0 \xa0 start_y = addy-(5+95)*2\n\xa0 \xa0 end_x = (9+95)*4+95\n\xa0 \xa0 end_y = 95+(5+95)*2\n\xa0 \xa0 return aimage[start_y:start_y+end_y, start_x:start_x+end_x]\n\n\n# 測試\n# 用實戰要改成1010\n# 訓練場1090\n\nJPG1 = "ph//screenshot1.png"\nimage = cv2.imread(JPG1)\nlook(pag(image))\n \n \n', 'tags': '', 'url': '測試框選範圍.html'}, {'title': '辨識改成多線程', 'text': '\n from concurrent import futures\nimport cv2\nfrom database import check,pag,output\nfrom main import timer\n\n\n\n@timer\ndef check_all(aimage):\n    """\n    檢查全部的圖片並返回成陣列\n    單片檢查\n    image1 = pag(image, addx+(9+95)*0, addy-(5+95)*2)\n    look(image1)\n    """\n    addx = 195\n    addy = 1090\n    # x 9 # y 5 # addx = 195 # addy = 1010\n    # 创建一个3x5的空二维數组\n    my_array = [[0 for j in range(5)] for i in range(3)]\n    futures_list = []\n    with futures.ThreadPoolExecutor() as executor:\n        for xx in range(5):\n            for yy in range(3):\n                image1 = pag(aimage, addx+(9+95)*xx, addy-(5+95)*yy)\n                future = executor.submit(check, image1)\n                futures_list.append((future, xx, yy))\n        for f, xx, yy in sorted(futures_list, key=lambda x: (x[1], x[2])):\n            my_array[yy][xx] = f.result()\n    my_array = my_array[::-1]\n    outpu = output(my_array)\n    print(outpu)\n    return my_array\nJPG1 = "screenshot1.png"\nimage = cv2.imread(JPG1)\nass = check_all(image)\n\'\'\'\'\'\' \n \n 速度差距 \n', 'tags': '', 'url': '辨識改成多線程.html'}, {'title': 'svm', 'text': '速度過慢 \n \n import cv2\nfrom sklearn import svm\n\n# 讀取圖像數據集和答案\ndata = []\nlabels = []\n\'\'\'\nwith open("C:/initpython/ph/dictionary.txt", "r", encoding="utf-8") as f:\n\xa0 \xa0 for i, line in enumerate(f):\n\xa0 \xa0 \xa0 \xa0 values = line.strip().split()\n\xa0 \xa0 \xa0 \xa0 if len(values) != 2:\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 print(f"Error: line {i+1} contains {len(values)} values.")\n\'\'\'\nwith open("C:/initpython/ph/dictionary.txt", "r", encoding="utf-8") as f:\n\xa0 \xa0 for line in f:\n\xa0 \xa0 \xa0 \xa0 filename, label = line.strip().split()\n\xa0 \xa0 \xa0 \xa0 print(filename)\n\xa0 \xa0 \xa0 \xa0 img = cv2.imread(f"C:/initpython/ph/jpg/{filename}.png", 0) \xa0# 讀取灰度圖像\n\xa0 \xa0 \xa0 \xa0 img = cv2.resize(img, (95, 95)) \xa0# 調整圖像大小\n\xa0 \xa0 \xa0 \xa0 data.append(img.flatten()) \xa0# 將圖像數據展平為一維數組\n\xa0 \xa0 \xa0 \xa0 labels.append(label) \xa0# 將答案添加到標籤列表中\n\n# 創建SVM模型\nclf = svm.SVC(kernel=\'linear\')\n\n# 訓練模型\nclf.fit(data, labels)\n\n# 讀取要預測的圖像\nimg = cv2.imread("C:/initpython/ph/jpg/1.png", 0) \xa0# 讀取灰度圖像\nimg = cv2.resize(img, (95, 95)) \xa0# 調整圖像大小\ndata = img.flatten() \xa0# 將圖像數據展平為一維數組\n\n# 預測圖像\nprediction = clf.predict([data]) \n', 'tags': '', 'url': 'svm.html'}, {'title': 'LeNet-5', 'text': '\n import cv2\nimport numpy as np\nimport tensorflow as tf\nfrom keras.models import Sequential\nfrom keras.layers import Conv2D, MaxPooling2D, Flatten, Dense\n\n# 設置GPU加速\ngpus = tf.config.experimental.list_physical_devices(\'GPU\')\nif gpus:\n\xa0 \xa0 try:\n\xa0 \xa0 \xa0 \xa0 tf.config.experimental.set_virtual_device_configuration(\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 gpus[0],\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 [tf.config.experimental.VirtualDeviceConfiguration(memory_limit=1024)]\n\xa0 \xa0 \xa0 \xa0 )\n\xa0 \xa0 except RuntimeError as e:\n\xa0 \xa0 \xa0 \xa0 print(e)\n\n\n\ndef create_model():\n\xa0 \xa0 model = Sequential()\n\xa0 \xa0 model.add(Conv2D(32, (3, 3), activation=\'relu\', input_shape=(95, 95, 1)))\n\xa0 \xa0 model.add(MaxPooling2D((2, 2)))\n\xa0 \xa0 model.add(Conv2D(64, (3, 3), activation=\'relu\'))\n\xa0 \xa0 model.add(MaxPooling2D((2, 2)))\n\xa0 \xa0 model.add(Conv2D(128, (3, 3), activation=\'relu\'))\n\xa0 \xa0 model.add(MaxPooling2D((2, 2)))\n\xa0 \xa0 model.add(Flatten())\n\xa0 \xa0 model.add(Dense(128, activation=\'relu\'))\n\xa0 \xa0 model.add(Dense(31, activation=\'softmax\')) \xa0# 將輸出層改為31個神經元\n\xa0 \xa0 model.compile(optimizer=\'adam\', loss=\'sparse_categorical_crossentropy\', metrics=[\'accuracy\'])\n\xa0 \xa0 return model\n\n\n# 訓練模型\ndef train_model():\n\xa0 \xa0 data = []\n\xa0 \xa0 labels = []\n\xa0 \xa0 label_map = {}\n\xa0 \xa0 with open("label_map.txt", "r", encoding="utf-8") as f: \xa0\n\xa0 \xa0 \xa0 \xa0 for line in f:\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 label, value = line.strip().split(":")\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 label_map[label] = int(value)\n\xa0 \xa0 with open("C:/initpython/ph/dictionary.txt", "r", encoding="utf-8") as f:\n\xa0 \xa0 \xa0 \xa0 for line in f:\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 filename, label = line.strip().split()\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 img = cv2.imread(f"C:/initpython/ph/jpg/{filename}.png", 0) \xa0# 讀取灰度圖像\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 img = cv2.resize(img, (95, 95)) \xa0# 調整圖像大小\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 data.append(img.reshape((95, 95, 1))) \xa0# 將圖像數據轉換為3D數組\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 if label in label_map:\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 labels.append(label_map[label]) \xa0# 將答案添加到標籤列表中\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 else:\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 print(f"Invalid label: {label}. Skipping this data.")\n\n\xa0 \xa0 data = np.array(data)\n\xa0 \xa0 labels = np.array(labels)\n\n\xa0 \xa0 model = create_model()\n\xa0 \xa0 model.fit(data, labels, epochs=10, batch_size=32)\n\n\xa0 \xa0 return model\n\n# 預測圖像\ndef predict_image(filename1, model):\n\xa0 \xa0 img = cv2.imread(filename1, 0) \xa0# 讀取灰度圖像\n\xa0 \xa0 img = cv2.resize(img, (95, 95)) \xa0# 調整圖像大小\n\xa0 \xa0 data = img.reshape((1, 95, 95, 1)) \xa0# 將圖像數據轉換為4D數組\n\n\xa0 \xa0 prediction = model.predict(data)\n\n\xa0 \xa0 return np.argmax(prediction)\n\n# 訓練模型\nmodel = train_model()\n\n# 預測圖像\nresult = predict_image("C:/initpython/ph/jpg/2.png", model)\nprint(f"This image belongs to class {result}.") \n', 'tags': '', 'url': 'LeNet-5.html'}, {'title': '小說爬蟲', 'text': '程式執行檔 \n import requests\nfrom bs4 import BeautifulSoup\nimport datetime\n\nfile_path = \'Book.txt\'  \nfile_path = \'書本.txt\'  \n\ndef print_hyperlink(text, url):\n    print(f"\\033]8;;{url}\\033\\\\{text}\\033]8;;\\033\\\\")\n\ndef count_lines_in_file(file_path):\n    """\n    檢查Book資料數\n    """\n    with open(file_path, \'r\',encoding=\'utf-8\') as file:\n        for line in file:\n            url = line.strip().split()[-1]\n            #print(line.strip().split()[0])\n            if (main(url.strip())) != []:\n                # print(line.strip().split()[0])\n                print_hyperlink(line.strip().split()[0],url)\n                print(main(url.strip()))\n                \n    \'\'\'\n        for line in file:\n            \'\'\'\n\n# 獲取現在的日期\ncurrent_date = datetime.date.today()\n# 將日期轉換為特定格式的字串\nformatted_date = current_date.strftime("%Y-%m-%d")\n\ndef main(url):\n    tagall= []\n    response = requests.get(url)\n    soup = BeautifulSoup(response.content.decode(\'gbk\'), \'html.parser\')\n\n    span_tags = soup.find_all([\'a\'])\n\n    for tag in span_tags:\n        if \'章\' in tag.text and formatted_date in tag.text:\n            #print(tag.text)\n            tagall = tag.text\n    return tagall\ncount_lines_in_file(file_path)\ninput("按下Enter退出...")\n \n 抓書籤程式 \n from bs4 import BeautifulSoup\n\ndef extract_h3_content_from_file(file_path):\n    with open(file_path, \'r\', encoding=\'utf-8\') as file:\n        html_data = file.read()\n\n    soup = BeautifulSoup(html_data, \'html.parser\')\n    h3_tags = soup.select(\'h3 > a\')#>span\n\n    h3_contents = []\n    for h3_tag in h3_tags:\n        h3_tag2 = h3_tag.select(\'span\')\n        if h3_tag2:\n            span_tag = h3_tag2[0]  # 获取第一个 <span> 标签\n            name = span_tag.text.strip()\n            h3_contents.append(name + \'  \' + \'https://www.69shu.com\' + h3_tag.get(\'href\'))\n            #print(name)\n\n    return h3_contents\n\nfile_path = \'mybook.txt\'  # 替换为你的文件路径\nh3_contents = extract_h3_content_from_file(file_path)\n\nfor content in h3_contents:\n    print(content)\n    pass\n    \ndef save_to_txt(file_path, data):\n    with open(file_path, \'w\', encoding=\'utf-8\') as file:\n        for item in data:\n            file.write(item + \'\\n\')\n\n# output_file_path = \'書名.txt\'  # 替换为你想要保存的文件路径\n# \noutput_file_path = \'書本.txt\'\nsave_to_txt(output_file_path, h3_contents)\n\'\'\'\'\'\' \n', 'tags': '', 'url': '小說爬蟲.html'}, {'title': '如何抓取html', 'text': '\n \n \n from bs4 import BeautifulSoup\nimport requests\nurl = "https://41023125.github.io/learning-process/content/index.html"\nresponse = requests.get(url)\nsoup = BeautifulSoup(response.content.decode(\'UTF-8\'), \'html.parser\')\nprint(soup) \n \n \n url 是想抓取的網址 \n response = requests.get(url)  發送GET請求到指定的URL，並將伺服器的回應存儲在 response 變數中。這個回應物件包含了網頁的內容、狀態碼、標頭信息等。 \n response有以下幾種輸出 \n 在這個情境下， <Response [200]>  表示成功從網頁伺服器接收到回應，並且狀態碼為 200。HTTP狀態碼是一種表示HTTP請求的結果的三位數字代碼。常見的狀態碼包括： \n \n 200: OK，表示請求成功，並且伺服器已成功返回所請求的數據。 \n 404: Not Found，表示所請求的資源在伺服器上未找到。 \n 500: Internal Server Error，表示伺服器在處理請求時遇到了內部錯誤。 \n \n GBK是中國的一種字符集編碼，常用於簡體中文的文字處理 \n 以下是一些常用的字符集（編碼）： \n \n \n UTF-8：這是一種廣泛使用的字符集，能夠表示世界上大部分語言的字符，包括英文字母、數字、拉丁字母、亞洲字符等。 \n \n \n ASCII：這是一種最基本的字符集，僅包含英文字母、數字和一些常用的符號，它是許多其他字符集的基礎。 \n \n \n ISO-8859-1（也稱為Latin-1）：這是一種字符集，能夠表示拉丁字母系統中的大部分字符，包括英文字母、西班牙語、法語、德語等。 \n \n \n GB2312：這是中國的一種字符集，能夠表示簡體中文的字符。 \n \n \n GBK：這是中國的一種字符集擴展，包含GB2312字符集的字符，並添加了更多的字符，也能夠表示簡體中文。 \n \n \n Big5：這是台灣的一種字符集，能夠表示繁體中文的字符。 \n \n \n Shift-JIS：這是日本的一種字符集，能夠表示日文的字符 \n \n \n \xa0 html.parser\'  是BeautifulSoup庫所使用的解析器，它能夠解析HTML文檔並構建相應的樹狀結構，方便後續對網頁內容進行操作和提取。 \n BeautifulSoup庫提供了不同的解析器（parser）來解析HTML或XML文檔。以下是BeautifulSoup庫中常用的解析器： \n \n \n \'html.parser\'：這是Python內置的HTML解析器，速度適中且不需要額外安裝其他庫。它可以解析網頁中的HTML標籤，並構建相應的樹狀結構。 \n \n \n \'lxml\'：這是一個基於C語言的庫，提供了快速且強大的HTML和XML解析功能。在安裝BeautifulSoup時需要單獨安裝lxml庫，可以透過pip工具進行安裝。 \n \n \n \'html5lib\'：這是一個純Python實現的HTML解析器，它的解析速度較慢，但在處理複雜的HTML文檔時更穩定且準確。 \n \n \n 這些解析器都有其優點和適用場景。通常，如果你需要解析複雜的HTML文檔，特別是在處理不完整或不符合標準的HTML時，建議使用\'lxml\'或\'html5lib\'解析器。而如果你僅需要基本的HTML解析功能，\'html.parser\'是一個輕量級和方便的選擇。 \n', 'tags': '', 'url': '如何抓取html.html'}, {'title': '提取資料', 'text': 'from bs4 import BeautifulSoup\nimport requests\nurl = "https://41023125.github.io/learning-process/content/index.html"\nresponse = requests.get(url)\nsoup = BeautifulSoup(response.coent.decode(\'UTF-8\'), \'html.parser\')\nspan_tags = soup.find_all([\'a\'])\nprint(span_tags)\n \n 延續前篇加入span_tags = soup.find_all([\'a\']) \n find_all  是 BeautifulSoup 中的一個方法，它用於尋找符合指定條件的所有元素。在這個例子中，條件是  [\'a\'] ，表示尋找所有的  <a>  標籤元素。 \n 除了  find_all  方法之外，BeautifulSoup 還提供了其他常用的方法來解析和操縱網頁的內容。以下是一些常見的 BeautifulSoup 方法： \n \n find(tag, attrs, recursive, text, **kwargs) ：尋找符合條件的第一個元素，與  find_all  類似，但只返回第一個匹配的結果。 \n find_next(tag, attrs, recursive, text, **kwargs) ：尋找下一個符合條件的元素。 \n find_all_next(tag, attrs, recursive, text, **kwargs) ：尋找之後所有符合條件的元素。 \n find_previous(tag, attrs, recursive, text, **kwargs) ：尋找前一個符合條件的元素。 \n find_all_previous(tag, attrs, recursive, text, **kwargs) ：尋找之前所有符合條件的元素。 \n select(selector) ：使用 CSS 選擇器選擇元素。 \n get_text() ：獲取元素的內容文本。 \n get(tag, default) ：獲取元素的屬性值。 \n has_attr(name) ：檢查元素是否具有指定的屬性。 \n prettify() ：以縮進和換行的方式返回美化後的 HTML 字符串。 \n \n <a>標籤是 HTML 中的超連結元素，通常用於創建鏈接到其他網頁或文件的文字或圖片。這行程式碼的目的是從 soup 物件中找到所有的<a> 標籤元素。 \n 例如想要抓取全部<a>標籤下的 href屬性裡面的內容\xa0 \n span_tags = soup.find_all(\'a\')\nfor span_tag in span_tags:\n    class_attr = span_tag.get("href")\n    if class_attr:\n        print(class_attr) \n 想要抓取 <a>  標籤所顯示的文字內容 \n a_tags = soup.find_all(\'a\')\nfor a_tag in a_tags:\n    text_content = a_tag.get_text()\n    print(text_content)\n \n 使用  get_text()  方法獲取  <a>  標籤內的文字內容 \n 使用  get_text()  方法時，它會返回所有子節點的文字內容，包括嵌套的子元素。如果只想獲取直接內容，而不包括子元素的文字，可以使用  string  屬性，像這樣： text_content = a_tag.string 。 \n', 'tags': '', 'url': '提取資料.html'}, {'title': '課表轉換器', 'text': '\n 原本的選課結果無法直觀的理解 \n 故希望能轉換成表格型式 \n 課表轉換器.7z \n 由於驗證碼系統無法利用爬蟲爬取資料 \n 故使用手動將選課結果的html複製於 課表.html 檔案中 \n 經由啟動main.exe 會轉換成 課表.xlsx \n from bs4 import BeautifulSoup\n# 讀取HTML文件\n# 有驗證碼問題未解決無法使用爬蟲 暫時自行抓取\nfile_path = "課表.html" \nwith open(file_path, "r", encoding="utf-8") as file: \n    # "r"：讀取模式，用於讀取檔案的內容。\n    # "w"：寫入模式，用於創建新的檔案或覆寫現有檔案的內容。\n    # "a"：附加模式，用於在現有檔案的末尾添加內容。\n    # "x"：獨佔創建模式，用於創建新的檔案，如果檔案已存在則引發錯誤。\n    #讀取的內容儲存在 html_content 變數中\n    html_content = file.read()  \n\n# 创建Beautiful Soup对象\nsoup = BeautifulSoup(html_content, "html.parser") \n#使用 BeautifulSoup 庫來解析 HTML 內容並尋找所有符合條件的 <tr> 標籤\nspan_tags = soup.find_all([\'tr\'])\n#allScheduletype分別儲存 課表種類,老師,教室,課號\nallScheduletype = [],[],[],[] \nfor tr_tag in span_tags:\n    #尋找所有符合條件的 <td> 標籤\n    td_tags = tr_tag.find_all(\'td\')\n    if len(td_tags) == 10:  \n        course_name = td_tags[3].get_text(separator=" ").strip().replace("<br/>", "")\n       \n        #get_text() 方法用於提取指定元素的文字內容。在這裡，separator=" " 參數指定在文字內容中多個節點之間使用空格作為分隔符。\n        #strip() 方法用於去除文字內容開頭和結尾的空格\n        #replace("<br/>", "") 方法用於將文字內容中的 <br/> 標籤替換為空字串，即將它們從文字中移除。\n        \n        course_name = course_name.split()[0]  \n        #將課表種類寫入\n        allScheduletype[0].append(course_name) \n        #將對應課堂老師寫入\n        allScheduletype[1].append(td_tags[7].get_text(separator=" ").strip()) \n        classroom = td_tags[8].get_text(separator=" ").strip()\n        classroom = classroom.split()[0]  \n        #將對應教室寫入\n        allScheduletype[2].append(classroom)\n        classroomNumber = td_tags[1].get_text(separator=" ").strip()\n        classroomNumber = classroomNumber.split()[0]   \n        #將對應課號寫入\n        allScheduletype[3].append(classroomNumber)\n\nstrings = []\ntimes = []\nfor tr_tag in span_tags:\n    td_tags = tr_tag.find_all(\'td\')\n    if len(td_tags) == 10:\n       strings.append (td_tags[9].get_text(separator=" ").strip())\nfor string in strings:\n    # 根据空格拆分字符串，并将拆分后的部分添加到结果列表中\n    times.append(string.split())\n# print(allScheduletype)0\n\n\n# 中文数字映射表\nnumber_mapping = {\n    "一": 1,\n    "二": 2,\n    "三": 3,\n    "四": 4,\n    "五": 5,\n    # 添加更多的映射，根据需要补充\n}\n\n\nimport pandas as pd\n\ngrid = [[""] * 20 for _ in range(20)]\n\n# 创建9行6列的格子\nweekdays = ["","星期一", "星期二", "星期三", "星期四", "星期五"]\nfor i in range(6):\n    grid[0][i] = weekdays[i]\nfor i in range(15):\n    grid[i+1][0] = "第"+str(i+1)+"節"\n\nfor x in range(len(times)):\n    for y in range (len(times[x])):\n        original = times[x][y]\n        # 分割中文数字和斜杠\n        chinese_digits, arabic_digit = original.split("/")\n        # 将中文数字转换为阿拉伯数字\n        arabic_digits = [number_mapping[chinese_digit] for chinese_digit in chinese_digits]\n        #print(arabic_digits[0],arabic_digit, allScheduletype[0][x])  \n        grid[int(arabic_digit)][arabic_digits[0]] = allScheduletype[0][x]+\'  \'+allScheduletype[2][x]\n#grid[][y] = allScheduletype[0][x]\nprint(grid)\n\n\n# 創建DataFrame对象\ndf = pd.DataFrame(grid)\n# 保存为Excel文件\nfile_path = "課表.xlsx"\ndf.to_excel(file_path, index=False, header=False, sheet_name="3上")\nwith pd.ExcelWriter(file_path, engine=\'xlsxwriter\') as writer:\n    df.to_excel(writer, index=False, header=False, sheet_name="3上")\n    worksheet = writer.sheets[\'3上\']\n\n    #調整行高\n    for i in range(df.shape[0]):\n        worksheet.set_row(i, height=25)\n\n    # 調整列寬\n    for i in range(df.shape[1]):\n        worksheet.set_column(i, i, width=44)\n        worksheet.set_column(0, 0, width=7)\n\n# 調用操作系统默認的程序開啟Excel文件\nimport subprocess\nsubprocess.Popen([\'start\', file_path], shell=True)\n\n\n \n', 'tags': '', 'url': '課表轉換器.html'}, {'title': '修課成員查詢器', 'text': '很常問同學有沒有選到自己上的課 \n 乾脆使用學校提供的表單配合爬蟲進行抓取 \n 快速獲取自己課堂的修課成員名單 \n 並可根據篩選查詢特定學號 \n """查看修課成員"""\nfrom bs4 import BeautifulSoup\nimport pandas as pd\nfrom selenium import webdriver\nimport time\nfrom selenium import webdriver\nfrom selenium.webdriver.chrome.options import Options\nfrom bs4 import BeautifulSoup\n\n#設定只顯示特定學號 \'\'則不篩選\nstudentID = "410231" \n\n# 讀取HTML文件\n# #有驗證碼問題未解決無法使用爬蟲 暫時自行抓取\nfile_path = "課表.html" \nwith open(file_path, "r", encoding="utf-8") as file: \n    # "r"：讀取模式，用於讀取檔案的內容。\n    # "w"：寫入模式，用於創建新的檔案或覆寫現有檔案的內容。\n    # "a"：附加模式，用於在現有檔案的末尾添加內容。\n    # "x"：獨佔創建模式，用於創建新的檔案，如果檔案已存在則引發錯誤。\n    #讀取的內容儲存在 html_content 變數中\n    html_content = file.read()  \n\n# 创建Beautiful Soup对象\nsoup = BeautifulSoup(html_content, "html.parser") \n#使用 BeautifulSoup 庫來解析 HTML 內容並尋找所有符合條件的 <tr> 標籤\nspan_tags = soup.find_all([\'tr\'])\n#allScheduletype分別儲存 課表種類,老師,教室,課號\nallScheduletype = [],[],[],[] \nfor tr_tag in span_tags:\n    #尋找所有符合條件的 <td> 標籤\n    td_tags = tr_tag.find_all(\'td\')\n    if len(td_tags) == 10:  \n        course_name = td_tags[3].get_text(separator=" ").strip().replace("<br/>", "")\n       \n        #get_text() 方法用於提取指定元素的文字內容。在這裡，separator=" " 參數指定在文字內容中多個節點之間使用空格作為分隔符。\n        #strip() 方法用於去除文字內容開頭和結尾的空格\n        #replace("<br/>", "") 方法用於將文字內容中的 <br/> 標籤替換為空字串，即將它們從文字中移除。\n        \n        course_name = course_name.split()[0]  \n        #將課表種類寫入\n        allScheduletype[0].append(course_name) \n        #將對應課堂老師寫入\n        allScheduletype[1].append(td_tags[7].get_text(separator=" ").strip()) \n        classroom = td_tags[8].get_text(separator=" ").strip()\n        classroom = classroom.split()[0]  \n        #將對應教室寫入\n        allScheduletype[2].append(classroom)\n        classroomNumber = td_tags[1].get_text(separator=" ").strip()\n        classroomNumber = classroomNumber.split()[0]   \n        #將對應課號寫入\n        allScheduletype[3].append(classroomNumber)\n\n#檢查課數\nlength = len(allScheduletype[3]) \n#依據課數建立陣列\nmy_array = [[] for _ in range(length)] \n\nimport threading\n#threading 模組提供了多執行緒編程的功能，允許在同一個程序中同時執行多個任務\ndef process_schedule(index):\n    #獲取課號\n    ineqno = allScheduletype[3][index]\n    #根據課號獲取相對url\n    url = \'https://qry.nfu.edu.tw/studlist.php?selyr=1121&seqno=\' + ineqno \n\n    # 建立Chrome選項物件\n    chrome_options = Options()\n    # 設定視窗不顯示\n    chrome_options.add_argument("--headless")\n    # 建立WebDriver物件\n    driver = webdriver.Chrome(\'chromedriver.exe\', options=chrome_options)\n\n    # 加載網頁\n    driver.get(url)\n\n \n    # 暫停0.2秒\n    time.sleep(0.2)  \n    # 獲取回應內容\n    content = driver.page_source\n    soup = BeautifulSoup(content, "html.parser") \n    #使用 BeautifulSoup 庫來解析 HTML 內容並尋找所有符合條件的 <tr> 標籤\n    span_tags = soup.find_all([\'tr\'])\n\n    # 在這裡處理回應的內容\n    text = \' \'.join([tag.get_text(separator=" ") for tag in span_tags[2:]]).strip()\n    word_lists = text.split()\n    for word_list in word_lists: \n        #查詢特定學號\n        if studentID in word_list:   \n            # 獲取鎖以避免多線程競爭\n            lock.acquire()\n            #寫入陣列\n            my_array[index].append(word_list)   \n            # 釋放鎖\n            lock.release()\n\n# 建立二維陣列\nmy_array = [[] for _ in range(len(allScheduletype[3]))]\n# 建立鎖物件\nlock = threading.Lock()\n\n# 互斥鎖是一種同步機制，用於保護共享資源的訪問，以避免多個執行緒同時對其進行修改或訪問而導致不一致的結果。\n# 在多執行緒環境中，如果多個執行緒同時試圖修改共享資源，可能會發生資源競爭 (race condition) 的情況。\n# 使用互斥鎖可以確保在任何時候只有一個執行緒可以擁有該鎖，從而確保共享資源的安全訪問。\n\n\n# 建立多個線程並執行任務\nthreads = []\nfor x in range(len(allScheduletype[3])):\n    thread = threading.Thread(target=process_schedule, args=(x,))\n    thread.start()\n    threads.append(thread)\n\n# 等待所有線程完成\nfor thread in threads:\n    thread.join()\n\n\n\n#all =[arr1, my_array[0], my_array[1], my_array[2], my_array[3], my_array[4], my_array[5], my_array[6],my_array[7],my_array[8],my_array[9],my_array[10]]\nall = [[\'\']] + [my_array[i] for i in range(length)]  #讓其根據選課數量做變化\n# 將每個陣列作為一行資料儲存到DataFrame中\n# DataFrame 的形狀（行數和列數）將取決於 all 中資料的結構和大小\ndf = pd.DataFrame(all)\n\n# 轉置DataFrame，使每個陣列的元素作為一列\ndf = df.transpose()\nallScheduletype[0].insert(0, \'\')\n# 加入列標題\ndf.columns = allScheduletype[0]\n\n#儲存DataFrame到Excel檔案，包含列標題和索引\nfile_path = "classmate.xlsx"\ndf.to_excel(file_path, index=False, header=True, sheet_name="3上")\nwith pd.ExcelWriter(file_path, engine=\'xlsxwriter\') as writer:\n    df.to_excel(writer, index=False, header=True, sheet_name="3上")\n    worksheet = writer.sheets[\'3上\']\n\n    # 調整列寬\n    for i in range(df.shape[1]):\n        worksheet.set_column(i, i, width=44)\n        worksheet.set_column(0, 0, width=7)\n\nimport subprocess\n#開啟檔案\nsubprocess.Popen([\'start\', "classmate.xlsx"], shell=True)\n \n', 'tags': '', 'url': '修課成員查詢器.html'}, {'title': 'other', 'text': '放置其他零散物品', 'tags': '', 'url': 'other.html'}, {'title': '建立倉儲', 'text': '進入github選擇new repository.png \n \n 填寫要建立的倉儲名稱 \n 並勾選 Add a README file後 \n 點選create repository進行建立 \n \n \n 進入建立的倉儲 \n 並點擊code選擇HTTPS or SSH複製連結 \n \n 開啟cmd \n 輸入git clone (複製的網址) \n (需先安裝好 git ) \n 倉儲的內容便會下載下來 \n', 'tags': '', 'url': '建立倉儲.html'}, {'title': '設定Personal access tokens(碼牌)', 'text': '打開github帳號點選右上頭像並點選Settings 點選Developer settings 點選Personal access tokens 點選 Generate new token Note (任意) 打勾repo(第一個) 點選最下面的Generate token 複製產生出來的token 打開可攜系統 打開要設Personal access tokens的資料夾 點開.git(要開隱藏項目才看的到) 將裡面的congif拉到SciTE(球球) 將複製的字串貼在github.com的前面再加上@並存檔(CTRL+S) 這樣Personal access tokens就設定完成 \n', 'tags': '', 'url': '設定Personal access tokens(碼牌).html'}, {'title': '可攜', 'text': '可攜模板.zip \n', 'tags': '', 'url': '可攜.html'}, {'title': 'key.py', 'text': 'key.py \n key.bat \n 將上方檔案放入倉儲內部 \n 並將碼牌放入特定txt檔後 \n 將txt位置放入key.py裡面 \n 需要時只需要輸入key便可以快速輸入碼牌 \n \n \n', 'tags': '', 'url': 'key.py.html'}, {'title': 'CMD', 'text': '遠端連線 mstsc 檢查sfc /scannow  chkdsk  chkdsk /r 外部curl -L ip.tool.lu ping 127.0.0.1 -t 性能監測器perfmon.msc 使用者帳戶net user \n', 'tags': '', 'url': 'CMD.html'}, {'title': 'question', 'text': '所遇到的問題與解決方法 \n 上傳檔案太大 \n', 'tags': '', 'url': 'question.html'}, {'title': '上傳檔案太大', 'text': '\n 取消commit \n 刪除過大的問題的文件 \n 改用雲端硬碟等方式 \n 重新commit \n', 'tags': '', 'url': '上傳檔案太大.html'}, {'title': '取消commit', 'text': 'git中如何取消 commit 操作 \n git reset --soft HEAD^ \n \n 這個命令將撤銷最後一個提交，但保留更改。如果您需要撤銷更多的提交，可以使用 HEAD~n \n 其中 n 是要撤銷的提交數量。例如，如果您要撤銷最後兩個提交，可以使用以下命令： \n git reset --soft HEAD~2 \n', 'tags': '', 'url': '取消commit.html'}, {'title': '恢復之前版本', 'text': 'Git恢复之前版本的两种方法reset、revert（图文详解） \n git reset --hard 目標版本號 \n \n', 'tags': '', 'url': '恢復之前版本.html'}, {'title': '強制push', 'text': 'Git 推送強制更改 \n git push origin main --force \n', 'tags': '', 'url': '強制push.html'}]};